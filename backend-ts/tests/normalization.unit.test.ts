/**
 * Normalization Unit Tests
 *
 * These tests validate that the TypeScript normalization implementation
 * produces identical output to the Python implementation.
 *
 * The golden fixtures are generated by Python and used as the reference.
 *
 * @see ../src/domain/normalization.ts
 * @see fixtures/normalization_golden.json
 */

import { describe, it, expect } from 'vitest'
import { createRequire } from 'module'

import {
  normalizeEquip,
  consonantSignature,
  expansionVariantsForQuery,
  stripAccents,
  normalizeText,
} from '../src/domain/normalization.js'

import { extractAttributes, extractAllAttributes } from '../src/domain/attributes.js'

// Load golden fixtures
const require = createRequire(import.meta.url)
const golden = require('./fixtures/normalization_golden.json') as GoldenCase[]

// =============================================================================
// TYPES
// =============================================================================

interface GoldenCase {
  case_name: string
  input: string
  output: {
    normalized: string
    consonant_key: string
    expansion_variants: string[]
    strip_accents: string
    normalize_text: string
    attributes_simple: {
      voltagem?: string
      tamanho_m?: number
    }
    attributes_full: {
      capacity_l?: number
      pressure_bar?: number
      diameter_mm?: number
      voltage_v?: number | string
      rpm?: number
      power_source?: string
    }
  }
}

// =============================================================================
// TESTS
// =============================================================================

describe('Normalization (TS vs Python golden)', () => {
  describe('normalizeEquip', () => {
    it.each(golden)('$case_name: normalizeEquip matches Python', (goldenCase) => {
      const result = normalizeEquip(goldenCase.input)
      expect(result).toBe(goldenCase.output.normalized)
    })
  })

  describe('consonantSignature', () => {
    it.each(golden)('$case_name: consonantSignature matches Python', (goldenCase) => {
      const result = consonantSignature(goldenCase.input)
      expect(result).toBe(goldenCase.output.consonant_key)
    })
  })

  describe('expansionVariantsForQuery', () => {
    it.each(golden)('$case_name: expansionVariantsForQuery matches Python', (goldenCase) => {
      const result = expansionVariantsForQuery(goldenCase.input)
      // Sort arrays for comparison since order may differ
      expect([...result].sort()).toEqual([...goldenCase.output.expansion_variants].sort())
    })
  })

  describe('stripAccents', () => {
    it.each(golden)('$case_name: stripAccents matches Python', (goldenCase) => {
      const result = stripAccents(goldenCase.input)
      expect(result).toBe(goldenCase.output.strip_accents)
    })
  })

  describe('normalizeText', () => {
    it.each(golden)('$case_name: normalizeText matches Python', (goldenCase) => {
      const result = normalizeText(goldenCase.input)
      expect(result).toBe(goldenCase.output.normalize_text)
    })
  })
})

describe('Attributes Extraction (TS vs Python golden)', () => {
  describe('extractAttributes (simple)', () => {
    it.each(golden)('$case_name: extractAttributes matches Python', (goldenCase) => {
      const result = extractAttributes(goldenCase.input)
      const expected = goldenCase.output.attributes_simple

      // Compare voltagem
      if (expected.voltagem !== undefined) {
        expect(result.voltagem).toBe(expected.voltagem)
      } else {
        expect(result.voltagem).toBeUndefined()
      }

      // Compare tamanho_m with tolerance for floating point
      if (expected.tamanho_m !== undefined) {
        expect(result.tamanho_m).toBeCloseTo(expected.tamanho_m, 5)
      } else {
        expect(result.tamanho_m).toBeUndefined()
      }
    })
  })

  describe('extractAllAttributes (full)', () => {
    it.each(golden)('$case_name: extractAllAttributes matches Python', (goldenCase) => {
      const result = extractAllAttributes(goldenCase.input)
      const expected = goldenCase.output.attributes_full

      // Compare capacity_l
      if (expected.capacity_l !== undefined) {
        expect(result.capacity_l).toBeCloseTo(expected.capacity_l, 5)
      } else {
        expect(result.capacity_l).toBeUndefined()
      }

      // Compare pressure_bar
      if (expected.pressure_bar !== undefined) {
        expect(result.pressure_bar).toBeCloseTo(expected.pressure_bar, 5)
      } else {
        expect(result.pressure_bar).toBeUndefined()
      }

      // Compare diameter_mm
      if (expected.diameter_mm !== undefined) {
        expect(result.diameter_mm).toBeCloseTo(expected.diameter_mm, 5)
      } else {
        expect(result.diameter_mm).toBeUndefined()
      }

      // Compare voltage_v (can be number or string)
      if (expected.voltage_v !== undefined) {
        expect(result.voltage_v).toBe(expected.voltage_v)
      } else {
        expect(result.voltage_v).toBeUndefined()
      }

      // Compare rpm
      if (expected.rpm !== undefined) {
        expect(result.rpm).toBeCloseTo(expected.rpm, 5)
      } else {
        expect(result.rpm).toBeUndefined()
      }

      // Compare power_source
      if (expected.power_source !== undefined) {
        expect(result.power_source).toBe(expected.power_source)
      } else {
        expect(result.power_source).toBeUndefined()
      }
    })
  })
})

// =============================================================================
// EDGE CASE TESTS
// =============================================================================

describe('Edge Cases', () => {
  it('normalizeEquip handles empty string', () => {
    expect(normalizeEquip('')).toBe('')
  })

  it('normalizeEquip handles null-like input', () => {
    expect(normalizeEquip(null as unknown as string)).toBe('')
  })

  it('stripAccents removes all common Portuguese accents', () => {
    expect(stripAccents('ácido')).toBe('acido')
    expect(stripAccents('elétrico')).toBe('eletrico')
    expect(stripAccents('manutenção')).toBe('manutencao')
    expect(stripAccents('ÁCIDO')).toBe('ACIDO')
  })

  it('consonantSignature produces consistent format', () => {
    const sig = consonantSignature('Motor 220V')
    expect(sig).toMatch(/^[a-z]+_\d*$/)
  })

  it('expansionVariantsForQuery returns empty for non-expandable terms', () => {
    expect(expansionVariantsForQuery('motor')).toEqual([])
  })
})

// =============================================================================
// UNIT EQUIVALENCE TESTS
// =============================================================================

describe('Unit Equivalence', () => {
  it('converts CV to HP', () => {
    const normalized = normalizeEquip('motor 5cv')
    expect(normalized).toContain('5hp')
    expect(normalized).not.toContain('cv')
  })

  it('normalizes volts to v when attached to number', () => {
    // Note: Python only joins when there's no space: "220v" not "220 volts"
    const normalized = normalizeEquip('motor 220v')
    expect(normalized).toContain('220v')
  })

  it('singularizes volts to volt when separate', () => {
    // When separated by space, singularization applies
    const normalized = normalizeEquip('motor 220 volts')
    expect(normalized).toContain('volt')
  })

  it('joins number and unit', () => {
    const normalized = normalizeEquip('motor 5 hp')
    expect(normalized).toContain('5hp')
  })
})
